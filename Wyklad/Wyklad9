Interfejs gniazd (sockets):
	*gniazda - obsluguje rozne rodzaje sieci, protokolow, nie potrzeba karty sieciowej by dziala
	*ogolnie to komunikacja sieciowa ale obsluguje komunikacje lokalna
	-Gniazda
		-mechanizm komunikacjyny miedzyprocesowej (IPC)
			-zaprojektowany dla obslugi sieci
			-rozwiniecie koncepcji potoku
				(komunikacja dwukierunkowa
			-model: klient-serwer
		-uniwersalny
			-rozne podsystemy komunikacyjne ( domeny )
			-rozne rodzaje polaczen
		-podsystemy ( domeny )
			-AF_UNIX, AF_LOCAL
			-AF_NETLINK
			-AF_INET, AF_INET6 ( domena internetu ipv4 i ipv6 )
			
			-AF_PACKET ( niskopoziomowe grzebanie w ramkach )
			*man 3 socket
		-typy gniazd
			-SOCK_STREAM ( komunikacja strumieniowa (bajty) )
			-SOCK_DGRAM ( komunikacja datagramowa )
			-SOCK_RAW ( bezposredniego dostepu )
			-SOCK_SEQPACKET ( komunikacja strumieniowa (komunikaty) )
			-SOCK_RDW ( komunikacja datagramowa wiarygodna )
		-obslugiwane typy zaleza od domeny
		-najpowszechniej stosowane typy gniazd
			-SOCK_STREAM
				*polaczeniowe, pewnosc transmisji, strumien danych (bajty)
			-SOCK_DGRAM
				*bezpolaczeniowe, brak kroekcji bledow, datagramy (komunikaty/paczki)
		*klient nie moze pasywnie czekac na serwer, jest strona aktywna	( model: master-slave )
	-Schematy uzytkowania
		-komunikacja datagramowa:
			*musi zawrzec informacje do kogo wysyla w pakiecie
	serwer										klient
	1.tworzy gniazda								1.utworzenie gniazda
	2.zarejestrowanie lokalizacji							2.w petli
	3.w petli										2.1.wysylanie zapytan(pod znany adres)
		3.1.odbieranie zapytan								2.2.odbieranie odpowiedzi
		3.2.wyslanie odpowiedzi							3.zamkniecie gniazda
	4.zamkniecie gniazda

		-komunikacja strumieniowa:
			*gniazdo ktore od kogo do kogo ma zawarta w sobie
	serwer										klient
	1.utworzenie gniazda								1.utworzenie gniazda
	2.zarejestrowanie lokalizacji
	3.zmiana trybu na pasywny ( z normalnego )
	4.oczekiwanie na polaczenie							2.nawizanie polaczenia ( ze znana lokalizacja )
		
			*polaczenie to osobny kanal komunikacyjny (po stronie serwera)
				*tworzone jest nowe gniazdo po stronie serwera
	5.w petli									3.w petli
		5.1.odbieranie zapytan								3.1.wysylanie zapytan
		5.1wysylanie odpowiedzi								3.2.odbieranie odpowiedzi
	6.zamkniecie gniazda (dodatkowego, istnieje wciaz to w trybie pasywnym)			4.zamkniecie gniazda

		-tworzenie gniazda
			int socket( ... )	-zwraca deskryptor (ten sam charakter jak te zwracane przez open)
				domain AF_...
			flagi
				*SOCK_NONBLOCK
				*SOCK_CLOEXEC
		-rejestrowanie lokalizacji	
			int bind( ... )
				struct sockaddr - uniwersalny typ adresowy, dla roznych domen stosuje sie rozne struktury
					-struct sockaddr_in	-dla internetowego polaczenia
					-struct sockaddr_sun
					-...
				addrlen -rzeczywisty rozmiar strukturalny

		-przejscie do trybu pasywnego
			int listen( ... )
				bakclog -rozmiar olejki dla polaczen oczekujacych

			uwaga:
				po zmianie trybu, gniazda nie mozna juz uzywac do zwyklej komunikacji
					*nie mozna gniazda odpasywnic i nie moze sluzyc do niczego innego jak odbierania polaczenia
		-tworzenie nowego deskryptora
			int accept( ... )
				*funkcja blokujaca (chyba ze gniazdo bylo nieblokujace)
				zwraca deskryptor nowego gniazda
			rozszerzenie Linuxa:
			int accept4( -||-, flagi )
				*w strukturze umiesci informacje kto sie z nami polaczyl
				flagi:
					SOCK_NONBLOCK
					SOCK_CLOEXEC
		-zamykanie polaczen -pod Linuxem nie ma uzasadnienia by stosowac zamykanie jednostronne
			int shutdown( ... ) 
				*zamkniecie jednostronne
				how:
					-SHUT_RD
					-SHUT_WR
					-SHUT_RDWR
		-zwalnianie gniazda
			int close( ... )
		-wysylanie danych
			ssize_t write( ... )
			ssize_t send( -||-, flagi )
			-komunikacja datagramowa
				ssize_t sendto( ... )
		-odbieranie danych
			ssize_t read( ... )
			ssize_t recv( -||-, flagi )	
			-komunikacja datagramowa
				*mozna uzyc zwyklej funkcji read jesli nie chcemy wiedziec od kogo przyszly dane
				ssize_t recvfrom( ... )
		-connect w gniazdach datagramowych
			*connect mozna uzyc w komunikacji datagramowej
			*connect blokuje informacje od kogo do kogo ida pakiety
			-kazda ze stron wykonuje niezaleznie
			-ustala parametry palaczenia (adres drugiej strony)
			-jest odwracalne
				afunset
				-konsekwencje
					-mozna uzywac prostszych funkcji
						*send, recv, read, write
					-system filtruje komunikacje
						-datagramy od innych nadawcow beda odrzucane
	Realizacja serwera komunikacji polaczeniowej
		-model: iteracyjny
			-akceptacja polaczenia
			-obsluga klienta
			-zamykanie polaczenia
			-czekanie na nastepnego klienta
			*dobry dla krotkiej obslugi
		-model: rownolegly
			*serwer ma potrafic obslugiwac wielu klientow
			*robie proces i robie forka	(duzo polaczeni nie mozna robic)
				*nowy proces obsluguje
				*stary proces czeka
			*robie watek (duzo polaczen nie mozna robic, nie wiecej niz 32k)
		-model: asynchroniczny
			*multipleksacja, jeden proces czeka na wielu desktryptorach (poll, select, epoll)
			-akceptacja i obsluga wielu olaczen
				-wszystko w jednym procesie
				-pasywne oczekiwanie na komunikaty
			-duzy stopien komplikacji
				-rozroznianie sesji i czegos
	Lokalna domena komunikacyjna
		-komunikacja
			-w obrebie jednego systemu
			-miedzy dowolnymi procesami
			-polaczeniowa i bezpolaczeniowa
			-wieksze mozliwosci
		-adresacja gniazd
			struct sockaddr_un{
				sa_family sun_family; //AF_UNIX
				*sciezka
			}
			-uzycie adresu
				-bind( ... )
					-sceizka ma lokalizowac plik
					-lokalizacja musi byc osiagalna
					-plik nie moze istniec
					-zostanie utworzony plik typu socket
					-nie da sie go otworzyc za pomoca open
					-mozna sie polaczyc za pomoca connect
					-adresy abstrakcyjne
						*nie tworzy zadnych plikow w systemie plikow
						sockaddr_sun
							char path[108];
								*dobrze jest robic sizeof i zapamietywac
								*najpierw jest \0 a pozniej 107 bajtow jest identyfikatorem
			*socketpair( ... ) - tworzy pare soketow polaczonych, nie trzeba nic robic, podobne do pipe
				*tak samo anonimowe, nie pojawiaja sie zadne pliki w systemie plikow
				*reszte jak w pipe
